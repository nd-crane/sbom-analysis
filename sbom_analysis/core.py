# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['show_metadata', 'show_entity_types', 'show_top_n_props', 'show_measures', 'file_schema', 'get_files_data',
           'get_files_graph', 'package_schema', 'get_package_data', 'get_package_graph', 'relationship_schema',
           'get_relationship_data', 'get_relationship_graph', 'visualize_graph', 'visualize_relationship_graph',
           'display_relationship_graph_legend']

# %% ../nbs/00_core.ipynb 6
from kglab import KnowledgeGraph
def show_metadata(kg:KnowledgeGraph, #Knowledge graph to query from
                  dataframe: bool=False): #Optionally, return result to dataframe
    """
    Return total number of triples, distict entities, and properties to a pandas dataframe.
    """
    
    query = """
    SELECT 
        (COUNT(*) AS ?triples)
        (COUNT(DISTINCT ?entity) AS ?entities)
        (COUNT(DISTINCT ?property) AS ?properties)
    WHERE {
        ?subject ?property ?object .
        BIND(?subject AS ?entity) .
    }
    """

    if dataframe:
        return kg.query_as_df(query)

    for row in kg.query(query):
        print("Total Triples:", row['triples'])
        print("Distinct Entities:", row['entities'])
        print("Distinct Properties:", row['properties'])

# %% ../nbs/00_core.ipynb 8
from kglab import KnowledgeGraph
def show_entity_types(kg: KnowledgeGraph, # Knowledge graph to query from 
                      dataframe: bool=False): # Optionally, return result to dataframe
    """
    Show counts of entity types
    """
    
    query = """
    SELECT ?type (COUNT(?entity) as ?count)
    WHERE {
        ?entity a ?type .
    }
    GROUP BY ?type
    ORDER BY DESC(?count)
    """
    
    if dataframe:
        return kg.query_as_df(query)

    result = kg.query(query)
    for row in result:
        print(row["type"], ":", row["count"])


# %% ../nbs/00_core.ipynb 10
from kglab import KnowledgeGraph
def show_top_n_props(kg: KnowledgeGraph,  # Knowledge graph to query from
                     n: int=10, # Top n results to display
                     dataframe: bool=False): # Optionally, return result to dataframe
    """
    Display the top N properties from a knowledge graph
    """
    
    query = """
    SELECT ?property (COUNT(?property) as ?count)
    WHERE {
        ?s ?property ?o .
    }
    GROUP BY ?property
    ORDER BY DESC(?count)
    LIMIT %d
    """ % n
    
    if dataframe:
        return kg.query_as_df(query)

    result = kg.query(query)
    for row in result:
        print(row["property"], ":", row["count"])

# %% ../nbs/00_core.ipynb 12
from kglab import KnowledgeGraph
def show_measures(kg:KnowledgeGraph): #Knowledge graph to query from
    """
    Display number of nodes and edges for knowledge graph
    """
    measure = kglab.Measure()
    measure.measure_graph(kg)

    print("edges", measure.get_edge_count())
    print("nodes", measure.get_node_count())

# %% ../nbs/00_core.ipynb 14
def file_schema(kg:KnowledgeGraph): #Knowledge graph to query from
  """
  Display all properties for a file
  """
  query = """
  PREFIX spdx:<http://spdx.org/rdf/terms#>
  SELECT DISTINCT ?property
  WHERE {
    ?file rdf:type spdx:File .
    ?file ?property ?value .
  }
  order by asc(UCASE(str(?property)))
  """
  return kg.query_as_df(query)

# %% ../nbs/00_core.ipynb 16
from pandas import DataFrame
def get_files_data(kg:KnowledgeGraph #Knowledge graph to query from
                   ) -> DataFrame: #Return result to dataframe
    """
    Return all files and their properties
    """
    query = """
    PREFIX spdx:<http://spdx.org/rdf/terms#>
    SELECT 
    (?file AS ?fileID)
    ?fileName
    ?fileType
    ?licenseInFile
    (GROUP_CONCAT(?contributor; SEPARATOR=", ") AS ?contributors)
    (GROUP_CONCAT(?licenseConcluded; SEPARATOR=", ") AS ?licenseConcluded)
    ?checksum
    ?relationship
    ?annotation
    ?comment
    ?licenseComments
    ?noticeText
    WHERE {
    ?file rdf:type spdx:File .
    OPTIONAL {?file spdx:fileName ?fileName .}
    OPTIONAL {?file spdx:fileContributor ?contributor .}
    OPTIONAL {?file spdx:licenseInfoInFile ?licenseInFile .}
    OPTIONAL {?file spdx:licenseConcluded ?licenseConcluded .}
    OPTIONAL {?file spdx:checksum ?checksum .}
    OPTIONAL {?file spdx:copyrightText ?copyrightText .}
    OPTIONAL {?file spdx:fileType ?fileType .}
    OPTIONAL {?file spdx:relationship ?relationship .}
    OPTIONAL {?file spdx:annotation ?annotation . }
    OPTIONAL {?file rdfs:comment ?comment . }
    OPTIONAL {?file spdx:licenseComments ?licenseComments . }
    OPTIONAL {?file spdx:noticeText ?noticeText . }
    }
    GROUP BY ?file
    """

    return kg.query_as_df(query)

# %% ../nbs/00_core.ipynb 18
def get_files_graph(kg:KnowledgeGraph #Knowledge graph to query from
                    )-> KnowledgeGraph: #Return result to knowledge graph
    """
    Return a subgraph of the files and their properties
    """
    namespaces = {
        "spdx": "http://spdx.org/rdf/terms#"
    }
    subgraph = kglab.KnowledgeGraph(
        namespaces = namespaces,
    )
    query = """
    PREFIX spdx:<http://spdx.org/rdf/terms#>
    CONSTRUCT {
        ?file rdf:type spdx:File .
        ?file spdx:fileName ?fileName .
        ?file spdx:fileContributor ?contributor .
        ?file spdx:licenseInfoInFile ?licenseInFile .
        ?file spdx:checksum ?checksum .
        ?file spdx:relationship ?relationship .
    }
    WHERE {
        ?file rdf:type spdx:File .
        OPTIONAL {?file spdx:fileName ?fileName .}
        OPTIONAL {?file spdx:fileContributor ?contributor .}
        OPTIONAL {?file spdx:licenseInfoInFile ?licenseInFile .}
        OPTIONAL {?file spdx:relationship ?relationship .}
    }
    """

    for row in kg.query(query):
        s, p, o = row
        subgraph.add(s, p, o)

    return subgraph # Return the subgraph

# %% ../nbs/00_core.ipynb 20
def package_schema(kg:KnowledgeGraph #Knowledge graph to query from
                  )-> DataFrame: #Return result to dataframe
  """
  Return the schema for the package
  """
  query = """
  PREFIX spdx:<http://spdx.org/rdf/terms#>
  SELECT DISTINCT ?property
  WHERE {
    ?package rdf:type spdx:Package .
    ?package ?property ?value .
  }
  order by asc(UCASE(str(?property)))
  """
  return kg.query_as_df(query)

# %% ../nbs/00_core.ipynb 22
def get_package_data(kg:KnowledgeGraph #Knowledge graph to query from
                     ) -> DataFrame: #Return result to dataframe
    """
    Construct a dataframe of package data
    """
    query = """
    PREFIX spdx:<http://spdx.org/rdf/terms#>
    SELECT ?package
        (GROUP_CONCAT(?annotation; SEPARATOR=", ") AS ?annotations)
        (GROUP_CONCAT(?attributionText; SEPARATOR=", ") AS ?attributionTexts)
        ?builtDate
        (GROUP_CONCAT(?checksum; SEPARATOR=", ") AS ?checksums)
        ?comment
        ?copyrightText
        ?description
        ?downloadLocation
        (GROUP_CONCAT(?externalRef; SEPARATOR=", ") AS ?externalRefs)
        ?filesAnalyzed
        (GROUP_CONCAT(?hasFile; SEPARATOR=", ") AS ?hasFiles)
        ?homepage
        ?licenseComments
        ?licenseConcluded
        ?licenseDeclared
        (GROUP_CONCAT(?licenseInfoFromFile; SEPARATOR=", ") AS ?licenseInfoFromFiles)
        ?name
        ?originator
        ?packageFileName
        ?packageVerificationCode
        ?primaryPackagePurpose
        ?releaseDate
        ?sourceInfo
        ?summary
        ?supplier
        ?validUntilDate
        ?versionInfo
        (GROUP_CONCAT(?relationship; SEPARATOR=", ") AS ?relationships)
    WHERE {
        ?package rdf:type spdx:Package .
        OPTIONAL { ?package spdx:annotation ?annotation . }
        OPTIONAL { ?package spdx:attributionText ?attributionText . }
        OPTIONAL { ?package spdx:builtDate ?buildDate . }
        OPTIONAL { ?package spdx:checksum ?checksum . }
        OPTIONAL { ?package spdx:comment ?comment . }
        OPTIONAL { ?package spdx:copyrightText ?copyrightText . }
        OPTIONAL { ?package spdx:description ?description . }
        OPTIONAL { ?package spdx:downloadLocation ?downloadLocation . }
        OPTIONAL { ?package spdx:externalRef ?externalRef . }
        OPTIONAL { ?package spdx:filesAnalyed ?filesAnalyzed . }
        OPTIONAL { ?package spdx:hasFile ?hasFile . }
        OPTIONAL { ?package spdx:homepage ?homepage . }
        OPTIONAL { ?package spdx:licenseComments ?licenseComments . }
        OPTIONAL { ?package spdx:licenseConcluded ?licenseConcluded . }
        OPTIONAL { ?package spdx:licenseDeclared ?licenseDeclared . }
        OPTIONAL { ?package spdx:licenseInfoFromFile ?licenseInfoFromFile . }
        OPTIONAL { ?package spdx:name ?name . }
        OPTIONAL { ?package spdx:originator ?originator . }
        OPTIONAL { ?package spdx:packageFileName ?packageFileName . }
        OPTIONAL { ?package spdx:packageVerificationCode ?packageVerificationCode . }
        OPTIONAL { ?package spdx:primaryPackagePurpose ?primaryPackagePurpose . }
        OPTIONAL { ?package spdx:releaseDate ?releaseDate . }
        OPTIONAL { ?package spdx:sourceInfo ?sourceInfo . }
        OPTIONAL { ?package spdx:summary ?summary . }
        OPTIONAL { ?package spdx:supplier ?supplier . }
        OPTIONAL { ?package spdx:validUntilDate ?validUntilDate . }
        OPTIONAL { ?package spdx:versionInfo ?versionInfo . }
        OPTIONAL { ?package spdx:relationship ?relationship . }
    }
    GROUP BY ?package
    """

    return kg.query_as_df(query)

# %% ../nbs/00_core.ipynb 24
def get_package_graph(kg:KnowledgeGraph #Knowledge graph to query from
                      ) -> KnowledgeGraph: #Return result to knowledge graph
    """
    Construct a subgraph of the package data
    """
    namespaces = {
        "spdx": "http://spdx.org/rdf/terms#"
    }   

    subgraph = kglab.KnowledgeGraph(
        namespaces = namespaces,
    )   

    query = """
    PREFIX spdx:<http://spdx.org/rdf/terms#>
    CONSTRUCT {
        ?package rdf:type spdx:Package .
        ?package spdx:annotation ?annotation .
        ?package spdx:attributionText ?attributionText .
        ?package spdx:builtDate ?buildDate .
        ?package spdx:checksum ?checksum .
        ?package spdx:comment ?comment .
        ?package spdx:copyrightText ?copyrightText .
        ?package spdx:description ?description .
        ?package spdx:downloadLocation ?downloadLocation .
        ?package spdx:externalRef ?externalRef .
        ?package spdx:filesAnalyed ?filesAnalyzed .
        ?package spdx:hasFile ?hasFile .
        ?package spdx:homepage ?homepage .
        ?package spdx:licenseComments ?licenseComments .
        ?package spdx:licenseConcluded ?licenseConcluded .
        ?package spdx:licenseDeclared ?licenseDeclared .
        ?package spdx:licenseInfoFromFile ?licenseInfoFromFile .
        ?package spdx:name ?name .
        ?package spdx:originator ?originator .
        ?package spdx:packageFileName ?packageFileName .
        ?package spdx:packageVerificationCode ?packageVerificationCode .
        ?package spdx:primaryPackagePurpose ?primaryPackagePurpose .
        ?package spdx:releaseDate ?releaseDate .
        ?package spdx:sourceInfo ?sourceInfo .
        ?package spdx:summary ?summary .
        ?package spdx:supplier ?supplier .
        ?package spdx:validUntilDate ?validUntilDate .
        ?package spdx:versionInfo ?versionInfo .
        ?package spdx:relationship ?relationship .
    }   
    WHERE {
        ?package rdf:type spdx:Package .
        OPTIONAL { ?package spdx:annotation ?annotation . }
        OPTIONAL { ?package spdx:attributionText ?attributionText . }
        OPTIONAL { ?package spdx:attributionText ?attributionText . }
        OPTIONAL { ?package spdx:builtDate ?buildDate . }
        OPTIONAL { ?package spdx:checksum ?checksum . }
        OPTIONAL { ?package spdx:comment ?comment . }
        OPTIONAL { ?package spdx:copyrightText ?copyrightText . }
        OPTIONAL { ?package spdx:description ?description . }
        OPTIONAL { ?package spdx:downloadLocation ?downloadLocation . }
        OPTIONAL { ?package spdx:externalRef ?externalRef . }
        OPTIONAL { ?package spdx:filesAnalyed ?filesAnalyzed . }
        OPTIONAL { ?package spdx:hasFile ?hasFile . }
        OPTIONAL { ?package spdx:homepage ?homepage . }
        OPTIONAL { ?package spdx:licenseComments ?licenseComments . }
        OPTIONAL { ?package spdx:licenseConcluded ?licenseConcluded . }
        OPTIONAL { ?package spdx:licenseDeclared ?licenseDeclared . }
        OPTIONAL { ?package spdx:licenseInfoFromFile ?licenseInfoFromFile . }
        OPTIONAL { ?package spdx:name ?name . }
        OPTIONAL { ?package spdx:originator ?originator . }
        OPTIONAL { ?package spdx:packageFileName ?packageFileName . }
        OPTIONAL { ?package spdx:packageVerificationCode ?packageVerificationCode . }
        OPTIONAL { ?package spdx:primaryPackagePurpose ?primaryPackagePurpose . }
        OPTIONAL { ?package spdx:releaseDate ?releaseDate . }
        OPTIONAL { ?package spdx:sourceInfo ?sourceInfo . }
        OPTIONAL { ?package spdx:summary ?summary . }
        OPTIONAL { ?package spdx:supplier ?supplier . }
        OPTIONAL { ?package spdx:validUntilDate ?validUntilDate . }
        OPTIONAL { ?package spdx:versionInfo ?versionInfo . }
        OPTIONAL { ?package spdx:relationship ?relationship . }
    }
    GROUP BY ?package
    """
    for row in kg.query(query):
        s, p, o = row
        subgraph.add(s, p, o)

    return subgraph # Return the subgraph

# %% ../nbs/00_core.ipynb 26
def relationship_schema(kg : KnowledgeGraph #Knowledge graph to query from
                        ) -> DataFrame: #Return result to dataframe
    """
    Return the schema for the relationships
    """

    query = """
    PREFIX spdx:<http://spdx.org/rdf/terms#>
    SELECT DISTINCT ?property
    WHERE {
    ?file rdf:type spdx:Relationship .
    ?file ?property ?value .
    }
    """


    return kg.query_as_df(query)


# %% ../nbs/00_core.ipynb 28
def get_relationship_data(kg:KnowledgeGraph #Knowledge graph to query from
                          ) -> DataFrame: #Return result to dataframe
    
    query = """
    PREFIX spdx:<http://spdx.org/rdf/terms#>
    SELECT ?element ?elementType ?relationshipType ?relatedElement ?relatedElementType
    WHERE {
    ?element spdx:relationship ?relationship .
    ?element rdf:type ?elementType .
    ?relationship spdx:relatedSpdxElement ?relatedElement .
    ?relationship spdx:relationshipType ?relationshipType .
    ?relatedElement rdf:type ?relatedElementType .
    }
    """

    return kg.query_as_df(query)

# %% ../nbs/00_core.ipynb 30
def get_relationship_graph(kg: KnowledgeGraph #Knowledge graph to query from
                           ) -> KnowledgeGraph: #Return result to knowledge graph
    """
    Construct a subgraph of the relationship data
    """

    namespaces = {
    "spdx": "http://spdx.org/rdf/terms#",
    }
    subgraph = kglab.KnowledgeGraph(
        namespaces = namespaces,
    )
    query = """
    PREFIX spdx:<http://spdx.org/rdf/terms#>
    CONSTRUCT {
    ?element spdx:relationship ?relationship .
    ?element rdf:type ?elementType .
    ?relationship spdx:relatedSpdxElement ?relatedElement .
    ?relationship spdx:relationshipType ?relationshipType .
    ?relatedElement rdf:type ?relatedElementType .
    }
    WHERE {
    ?element spdx:relationship ?relationship .
    ?element rdf:type ?elementType .
    ?relationship spdx:relatedSpdxElement ?relatedElement .
    ?relationship spdx:relationshipType ?relationshipType .
    ?relatedElement rdf:type ?relatedElementType .
    }
    """

    for row in kg.query(query):
        s, p, o = row
        subgraph.add(s, p, o)

    return subgraph

# %% ../nbs/00_core.ipynb 34
import kglab
def visualize_graph(kg:KnowledgeGraph, #Knowledge graph to query from
                    VIS_STYLE: str={} #Optional, visualization style
                    ):
    """
    Visualize the knowledge graph
    """
    if not VIS_STYLE:
        VIS_STYLE = {
            "spdx": {
                "color": "orange",
                "size": 40,
            },
            "rdf":{
                "color": "blue",
                "size": 30,
            },
            "ptr":{
                "color": "red",
                "size": 20,
            },
        }
    subgraph = kglab.SubgraphTensor(kg)
    return subgraph.build_pyvis_graph(notebook=True, style=VIS_STYLE)

# %% ../nbs/00_core.ipynb 36
import kglab
from pyvis.network import Network

def visualize_relationship_graph(
    kg: KnowledgeGraph,     # Knowledge graph to query from
    hideTypeFile: str=False # Flag for showing SPDX:File type components in the graph
    ) -> Network:           # Return a Network object representing the SBOMs relationship graph

    """
    Construct a Network object for representing the SBOMs components relationship graph.
    The returned graph is ready to be visualized using `.show()`. 
    """
    
    def get_node_title(elmName: str, elmType: str, elmVersion: str, elemPurpose: str) -> str:
        """
        Create a node title. 
        The title will be the node hover text.
        """
        nodeTitle = f"{elmType}: {elmName}"
        if elmVersion:
            nodeTitle += f"\nVersion:{elmVersion}"
        if elemPurpose:
            nodeTitle += "\nPurpose: " + elemPurpose.split("purpose_")[1]
        return nodeTitle

    def get_node_label(elmName: str, elmVersion: str) -> str:
        """
        Create a node label. 
        The label will be the text under the node.
        """
        nodeLabel = elmName
        if elmVersion: nodeLabel += "==" + elmVersion
        return nodeLabel
    
       
    VIS_STYLE = { 
        'SpdxDocument': {
            "color": "#DE3163",
            "size": 20,
        },
        'Package': {
            "color": "#99ccff",
            "size": 20,
        },
        'File': {
            "color": "#FFBF00",
            "size": 15,
        },
    }
    
    SPDX_NS = "http://spdx.org/rdf/terms#"
    
    QUERY = """
    PREFIX spdx:<http://spdx.org/rdf/terms#>
    PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
    
    SELECT
        ?element
        ?elementName
        ?elementType
        ?elementVersionInfo
        ?elementPrimaryPackagePurpose
        ?relatedElement
        ?relationshipType
        ?relatedElementName
        ?relatedElementType
        ?relatedElementVersionInfo
        ?relatedElementPrimaryPackagePurpose
        
    WHERE {
        ?element spdx:relationship ?relationship .
        ?element rdf:type ?elementType .
        ?relationship spdx:relatedSpdxElement ?relatedElement .
        ?relationship spdx:relationshipType ?relationshipType .
        ?relatedElement rdf:type ?relatedElementType .
        
        OPTIONAL { ?element spdx:name ?elementName . }
        OPTIONAL { ?element spdx:fileName ?elementName . }
        OPTIONAL { ?element spdx:primaryPackagePurpose ?elementPrimaryPackagePurpose . }
        OPTIONAL { ?relatedElement spdx:name ?relatedElementName . }
        OPTIONAL { ?relatedElement spdx:fileName ?relatedElementName . }
        OPTIONAL { ?element spdx:versionInfo ?elementVersionInfo .}
        OPTIONAL { ?relatedElement spdx:versionInfo ?relatedElementVersionInfo .}
        OPTIONAL { ?relatedElement spdx:primaryPackagePurpose ?relatedElementPrimaryPackagePurpose . }
    }
    """
    
    # run query
    query_result = kg.query(QUERY)

    # hide from query_result the components of the spdx:File type     
    if hideTypeFile:
        query_result = [ row for row in query_result if str(row.relatedElementType).split(SPDX_NS)[-1] != "File"]
        
    # create a graph of the relationships using Network
    relationship_graph = Network(notebook=True, directed=True, cdn_resources="remote")
    
    # update the graph of the relationships based on the query_result
    for row in query_result:
        
        # element
        elementName = str(row.elementName)
        elementType = str(row.elementType).split(SPDX_NS)[-1]
        elementVersionInfo = row.elementVersionInfo
        elementPrimaryPackagePurpose= row.elementPrimaryPackagePurpose
        
        # relationship
        relationshipTypeName = row.relationshipType.split("relationshipType_")[1]
        
        # relatedElement        
        relatedElementName = str(row.relatedElementName)
        relatedElementType = str(row.relatedElementType).split(SPDX_NS)[-1]
        relatedElementVersionInfo = row.relatedElementVersionInfo
        relatedElementPrimaryPackagePurpose = row.relatedElementPrimaryPackagePurpose

        ## update graph
        # element Node info
        elementNodeId = row.element 
        elementNodeLabel = get_node_label(elementName, elementVersionInfo)
        elementNodeTitle = get_node_title(elementName, elementType, 
                                          elementVersionInfo, elementPrimaryPackagePurpose)
        elementNodeColor = VIS_STYLE[elementType]['color']
        elementNodeSize = VIS_STYLE[elementType]['size']        
        
        # relatedElement Node info
        relatedElementNodeId = row.relatedElement 
        relatedElementNodeLabel = get_node_label(relatedElementName, relatedElementVersionInfo)
        relatedElementNodeTitle = get_node_title(relatedElementName, relatedElementType, 
                                                 relatedElementVersionInfo, relatedElementPrimaryPackagePurpose)
        relatedElementNodeColor = VIS_STYLE[relatedElementType]['color']
        relatedElementNodeSize = VIS_STYLE[relatedElementType]['size']            
        
        # add nodes (elementName, relatedElementName) to the graph
        relationship_graph.add_node(elementNodeId,
                                    label = elementNodeLabel,
                                    title = elementNodeTitle,
                                    color = elementNodeColor,
                                    size = elementNodeSize
                                   )
        relationship_graph.add_node(relatedElementNodeId,
                                    label = relatedElementNodeLabel,
                                    title = relatedElementNodeTitle,
                                    color = relatedElementNodeColor,
                                    size = relatedElementNodeSize
                                   )
        # and edge(relatedElementName) to the graph
        relationship_graph.add_edge(elementNodeId,
                                    relatedElementNodeId,
                                    title = relationshipTypeName,
                                    label = relationshipTypeName # text over the edge
                                   )
    return relationship_graph

# %% ../nbs/00_core.ipynb 37
from pandas import DataFrame
def display_relationship_graph_legend():    
    """
    Display the legend of the SBOMs components relationship graph that can be visualized by `visualize_relationship_graph()`.
    """    
    legend_df = DataFrame([['File', 'Yellow'], ['Package', 'Blue'], ['SPDXDocument', 'Red']], 
                  columns=['SPDX Type', 'Node Color'])

    display(legend_df)

