# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/sboms/00_core.ipynb.

# %% auto 0
__all__ = ['show_metadata', 'show_entity_types', 'show_top_n_props', 'show_measures', 'file_schema', 'get_files_data',
           'get_files_graph', 'package_schema', 'get_package_data', 'get_package_graph', 'relationship_schema',
           'get_relationship_data', 'get_relationship_graph', 'sbomqs_scores', 'sbomqs_score_by_cat', 'visualize_graph',
           'visualize_relationship_graph', 'display_relationship_graph_legend', 'display_qscores_with_descriptions',
           'display_category_qscores_heatmap', 'display_qscores_heatmap', 'sbomqs_radar_chart']

# %% ../nbs/sboms/00_core.ipynb 6
from kglab import KnowledgeGraph
def show_metadata(kg:KnowledgeGraph, #Knowledge graph to query from
                  dataframe: bool=False): #Optionally, return result to dataframe
    """
    Return total number of triples, distict entities, and properties to a pandas dataframe.
    """
    
    query = """
    SELECT 
        (COUNT(*) AS ?triples)
        (COUNT(DISTINCT ?entity) AS ?entities)
        (COUNT(DISTINCT ?property) AS ?properties)
    WHERE {
        ?subject ?property ?object .
        BIND(?subject AS ?entity) .
    }
    """

    if dataframe:
        return kg.query_as_df(query)

    for row in kg.query(query):
        print("Total Triples:", row['triples'])
        print("Distinct Entities:", row['entities'])
        print("Distinct Properties:", row['properties'])

# %% ../nbs/sboms/00_core.ipynb 8
from kglab import KnowledgeGraph
def show_entity_types(kg: KnowledgeGraph, # Knowledge graph to query from 
                      dataframe: bool=False): # Optionally, return result to dataframe
    """
    Show counts of entity types
    """
    
    query = """
    SELECT ?type (COUNT(?entity) as ?count)
    WHERE {
        ?entity a ?type .
    }
    GROUP BY ?type
    ORDER BY DESC(?count)
    """
    
    if dataframe:
        return kg.query_as_df(query)

    result = kg.query(query)
    for row in result:
        print(row["type"], ":", row["count"])


# %% ../nbs/sboms/00_core.ipynb 10
from kglab import KnowledgeGraph
def show_top_n_props(kg: KnowledgeGraph,  # Knowledge graph to query from
                     n: int=10, # Top n results to display
                     dataframe: bool=False): # Optionally, return result to dataframe
    """
    Display the top N properties from a knowledge graph
    """
    
    query = """
    SELECT ?property (COUNT(?property) as ?count)
    WHERE {
        ?s ?property ?o .
    }
    GROUP BY ?property
    ORDER BY DESC(?count)
    LIMIT %d
    """ % n
    
    if dataframe:
        return kg.query_as_df(query)

    result = kg.query(query)
    for row in result:
        print(row["property"], ":", row["count"])

# %% ../nbs/sboms/00_core.ipynb 12
from kglab import KnowledgeGraph
def show_measures(kg:KnowledgeGraph): #Knowledge graph to query from
    """
    Display number of nodes and edges for knowledge graph
    """
    measure = kglab.Measure()
    measure.measure_graph(kg)

    print("edges", measure.get_edge_count())
    print("nodes", measure.get_node_count())

# %% ../nbs/sboms/00_core.ipynb 14
def file_schema(kg:KnowledgeGraph): #Knowledge graph to query from
  """
  Display all properties for a file
  """
  query = """
  PREFIX spdx:<http://spdx.org/rdf/terms#>
  SELECT DISTINCT ?property
  WHERE {
    ?file rdf:type spdx:File .
    ?file ?property ?value .
  }
  order by asc(UCASE(str(?property)))
  """
  return kg.query_as_df(query)

# %% ../nbs/sboms/00_core.ipynb 16
from pandas import DataFrame
def get_files_data(kg:KnowledgeGraph #Knowledge graph to query from
                   ) -> DataFrame: #Return result to dataframe
    """
    Return all files and their properties
    """
    query = """
    PREFIX spdx:<http://spdx.org/rdf/terms#>
    SELECT 
    (?file AS ?fileID)
    ?fileName
    ?fileType
    ?licenseInFile
    (GROUP_CONCAT(?contributor; SEPARATOR=", ") AS ?contributors)
    (GROUP_CONCAT(?licenseConcluded; SEPARATOR=", ") AS ?licenseConcluded)
    ?checksum
    ?relationship
    ?annotation
    ?comment
    ?licenseComments
    ?noticeText
    WHERE {
    ?file rdf:type spdx:File .
    OPTIONAL {?file spdx:fileName ?fileName .}
    OPTIONAL {?file spdx:fileContributor ?contributor .}
    OPTIONAL {?file spdx:licenseInfoInFile ?licenseInFile .}
    OPTIONAL {?file spdx:licenseConcluded ?licenseConcluded .}
    OPTIONAL {?file spdx:checksum ?checksum .}
    OPTIONAL {?file spdx:copyrightText ?copyrightText .}
    OPTIONAL {?file spdx:fileType ?fileType .}
    OPTIONAL {?file spdx:relationship ?relationship .}
    OPTIONAL {?file spdx:annotation ?annotation . }
    OPTIONAL {?file rdfs:comment ?comment . }
    OPTIONAL {?file spdx:licenseComments ?licenseComments . }
    OPTIONAL {?file spdx:noticeText ?noticeText . }
    }
    GROUP BY ?file
    """

    return kg.query_as_df(query)

# %% ../nbs/sboms/00_core.ipynb 18
def get_files_graph(kg:KnowledgeGraph #Knowledge graph to query from
                    )-> KnowledgeGraph: #Return result to knowledge graph
    """
    Return a subgraph of the files and their properties
    """
    namespaces = {
        "spdx": "http://spdx.org/rdf/terms#"
    }
    subgraph = kglab.KnowledgeGraph(
        namespaces = namespaces,
    )
    query = """
    PREFIX spdx:<http://spdx.org/rdf/terms#>
    CONSTRUCT {
        ?file rdf:type spdx:File .
        ?file spdx:fileName ?fileName .
        ?file spdx:fileContributor ?contributor .
        ?file spdx:licenseInfoInFile ?licenseInFile .
        ?file spdx:checksum ?checksum .
        ?file spdx:relationship ?relationship .
    }
    WHERE {
        ?file rdf:type spdx:File .
        OPTIONAL {?file spdx:fileName ?fileName .}
        OPTIONAL {?file spdx:fileContributor ?contributor .}
        OPTIONAL {?file spdx:licenseInfoInFile ?licenseInFile .}
        OPTIONAL {?file spdx:relationship ?relationship .}
    }
    """

    for row in kg.query(query):
        s, p, o = row
        subgraph.add(s, p, o)

    return subgraph # Return the subgraph

# %% ../nbs/sboms/00_core.ipynb 20
def package_schema(kg:KnowledgeGraph #Knowledge graph to query from
                  )-> DataFrame: #Return result to dataframe
  """
  Return the schema for the package
  """
  query = """
  PREFIX spdx:<http://spdx.org/rdf/terms#>
  SELECT DISTINCT ?property
  WHERE {
    ?package rdf:type spdx:Package .
    ?package ?property ?value .
  }
  order by asc(UCASE(str(?property)))
  """
  return kg.query_as_df(query)

# %% ../nbs/sboms/00_core.ipynb 22
def get_package_data(kg:KnowledgeGraph #Knowledge graph to query from
                     ) -> DataFrame: #Return result to dataframe
    """
    Construct a dataframe of package data
    """
    query = """
    PREFIX spdx:<http://spdx.org/rdf/terms#>
    SELECT ?package
        (GROUP_CONCAT(?annotation; SEPARATOR=", ") AS ?annotations)
        (GROUP_CONCAT(?attributionText; SEPARATOR=", ") AS ?attributionTexts)
        ?builtDate
        (GROUP_CONCAT(?checksum; SEPARATOR=", ") AS ?checksums)
        ?comment
        ?copyrightText
        ?description
        ?downloadLocation
        (GROUP_CONCAT(?externalRef; SEPARATOR=", ") AS ?externalRefs)
        ?filesAnalyzed
        (GROUP_CONCAT(?hasFile; SEPARATOR=", ") AS ?hasFiles)
        ?homepage
        ?licenseComments
        ?licenseConcluded
        ?licenseDeclared
        (GROUP_CONCAT(?licenseInfoFromFile; SEPARATOR=", ") AS ?licenseInfoFromFiles)
        ?name
        ?originator
        ?packageFileName
        ?packageVerificationCode
        ?primaryPackagePurpose
        ?releaseDate
        ?sourceInfo
        ?summary
        ?supplier
        ?validUntilDate
        ?versionInfo
        (GROUP_CONCAT(?relationship; SEPARATOR=", ") AS ?relationships)
    WHERE {
        ?package rdf:type spdx:Package .
        OPTIONAL { ?package spdx:annotation ?annotation . }
        OPTIONAL { ?package spdx:attributionText ?attributionText . }
        OPTIONAL { ?package spdx:builtDate ?buildDate . }
        OPTIONAL { ?package spdx:checksum ?checksum . }
        OPTIONAL { ?package spdx:comment ?comment . }
        OPTIONAL { ?package spdx:copyrightText ?copyrightText . }
        OPTIONAL { ?package spdx:description ?description . }
        OPTIONAL { ?package spdx:downloadLocation ?downloadLocation . }
        OPTIONAL { ?package spdx:externalRef ?externalRef . }
        OPTIONAL { ?package spdx:filesAnalyed ?filesAnalyzed . }
        OPTIONAL { ?package spdx:hasFile ?hasFile . }
        OPTIONAL { ?package spdx:homepage ?homepage . }
        OPTIONAL { ?package spdx:licenseComments ?licenseComments . }
        OPTIONAL { ?package spdx:licenseConcluded ?licenseConcluded . }
        OPTIONAL { ?package spdx:licenseDeclared ?licenseDeclared . }
        OPTIONAL { ?package spdx:licenseInfoFromFile ?licenseInfoFromFile . }
        OPTIONAL { ?package spdx:name ?name . }
        OPTIONAL { ?package spdx:originator ?originator . }
        OPTIONAL { ?package spdx:packageFileName ?packageFileName . }
        OPTIONAL { ?package spdx:packageVerificationCode ?packageVerificationCode . }
        OPTIONAL { ?package spdx:primaryPackagePurpose ?primaryPackagePurpose . }
        OPTIONAL { ?package spdx:releaseDate ?releaseDate . }
        OPTIONAL { ?package spdx:sourceInfo ?sourceInfo . }
        OPTIONAL { ?package spdx:summary ?summary . }
        OPTIONAL { ?package spdx:supplier ?supplier . }
        OPTIONAL { ?package spdx:validUntilDate ?validUntilDate . }
        OPTIONAL { ?package spdx:versionInfo ?versionInfo . }
        OPTIONAL { ?package spdx:relationship ?relationship . }
    }
    GROUP BY ?package
    """

    return kg.query_as_df(query)

# %% ../nbs/sboms/00_core.ipynb 24
def get_package_graph(kg:KnowledgeGraph #Knowledge graph to query from
                      ) -> KnowledgeGraph: #Return result to knowledge graph
    """
    Construct a subgraph of the package data
    """
    namespaces = {
        "spdx": "http://spdx.org/rdf/terms#"
    }   

    subgraph = kglab.KnowledgeGraph(
        namespaces = namespaces,
    )   

    query = """
    PREFIX spdx:<http://spdx.org/rdf/terms#>
    CONSTRUCT {
        ?package rdf:type spdx:Package .
        ?package spdx:annotation ?annotation .
        ?package spdx:attributionText ?attributionText .
        ?package spdx:builtDate ?buildDate .
        ?package spdx:checksum ?checksum .
        ?package spdx:comment ?comment .
        ?package spdx:copyrightText ?copyrightText .
        ?package spdx:description ?description .
        ?package spdx:downloadLocation ?downloadLocation .
        ?package spdx:externalRef ?externalRef .
        ?package spdx:filesAnalyed ?filesAnalyzed .
        ?package spdx:hasFile ?hasFile .
        ?package spdx:homepage ?homepage .
        ?package spdx:licenseComments ?licenseComments .
        ?package spdx:licenseConcluded ?licenseConcluded .
        ?package spdx:licenseDeclared ?licenseDeclared .
        ?package spdx:licenseInfoFromFile ?licenseInfoFromFile .
        ?package spdx:name ?name .
        ?package spdx:originator ?originator .
        ?package spdx:packageFileName ?packageFileName .
        ?package spdx:packageVerificationCode ?packageVerificationCode .
        ?package spdx:primaryPackagePurpose ?primaryPackagePurpose .
        ?package spdx:releaseDate ?releaseDate .
        ?package spdx:sourceInfo ?sourceInfo .
        ?package spdx:summary ?summary .
        ?package spdx:supplier ?supplier .
        ?package spdx:validUntilDate ?validUntilDate .
        ?package spdx:versionInfo ?versionInfo .
        ?package spdx:relationship ?relationship .
    }   
    WHERE {
        ?package rdf:type spdx:Package .
        OPTIONAL { ?package spdx:annotation ?annotation . }
        OPTIONAL { ?package spdx:attributionText ?attributionText . }
        OPTIONAL { ?package spdx:attributionText ?attributionText . }
        OPTIONAL { ?package spdx:builtDate ?buildDate . }
        OPTIONAL { ?package spdx:checksum ?checksum . }
        OPTIONAL { ?package spdx:comment ?comment . }
        OPTIONAL { ?package spdx:copyrightText ?copyrightText . }
        OPTIONAL { ?package spdx:description ?description . }
        OPTIONAL { ?package spdx:downloadLocation ?downloadLocation . }
        OPTIONAL { ?package spdx:externalRef ?externalRef . }
        OPTIONAL { ?package spdx:filesAnalyed ?filesAnalyzed . }
        OPTIONAL { ?package spdx:hasFile ?hasFile . }
        OPTIONAL { ?package spdx:homepage ?homepage . }
        OPTIONAL { ?package spdx:licenseComments ?licenseComments . }
        OPTIONAL { ?package spdx:licenseConcluded ?licenseConcluded . }
        OPTIONAL { ?package spdx:licenseDeclared ?licenseDeclared . }
        OPTIONAL { ?package spdx:licenseInfoFromFile ?licenseInfoFromFile . }
        OPTIONAL { ?package spdx:name ?name . }
        OPTIONAL { ?package spdx:originator ?originator . }
        OPTIONAL { ?package spdx:packageFileName ?packageFileName . }
        OPTIONAL { ?package spdx:packageVerificationCode ?packageVerificationCode . }
        OPTIONAL { ?package spdx:primaryPackagePurpose ?primaryPackagePurpose . }
        OPTIONAL { ?package spdx:releaseDate ?releaseDate . }
        OPTIONAL { ?package spdx:sourceInfo ?sourceInfo . }
        OPTIONAL { ?package spdx:summary ?summary . }
        OPTIONAL { ?package spdx:supplier ?supplier . }
        OPTIONAL { ?package spdx:validUntilDate ?validUntilDate . }
        OPTIONAL { ?package spdx:versionInfo ?versionInfo . }
        OPTIONAL { ?package spdx:relationship ?relationship . }
    }
    GROUP BY ?package
    """
    for row in kg.query(query):
        s, p, o = row
        subgraph.add(s, p, o)

    return subgraph # Return the subgraph

# %% ../nbs/sboms/00_core.ipynb 26
def relationship_schema(kg : KnowledgeGraph #Knowledge graph to query from
                        ) -> DataFrame: #Return result to dataframe
    """
    Return the schema for the relationships
    """

    query = """
    PREFIX spdx:<http://spdx.org/rdf/terms#>
    SELECT DISTINCT ?property
    WHERE {
    ?file rdf:type spdx:Relationship .
    ?file ?property ?value .
    }
    """


    return kg.query_as_df(query)


# %% ../nbs/sboms/00_core.ipynb 28
def get_relationship_data(kg:KnowledgeGraph #Knowledge graph to query from
                          ) -> DataFrame: #Return result to dataframe
    
    query = """
    PREFIX spdx:<http://spdx.org/rdf/terms#>
    SELECT ?element ?elementType ?relationshipType ?relatedElement ?relatedElementType
    WHERE {
    ?element spdx:relationship ?relationship .
    ?element rdf:type ?elementType .
    ?relationship spdx:relatedSpdxElement ?relatedElement .
    ?relationship spdx:relationshipType ?relationshipType .
    ?relatedElement rdf:type ?relatedElementType .
    }
    """

    return kg.query_as_df(query)

# %% ../nbs/sboms/00_core.ipynb 30
def get_relationship_graph(kg: KnowledgeGraph #Knowledge graph to query from
                           ) -> KnowledgeGraph: #Return result to knowledge graph
    """
    Construct a subgraph of the relationship data
    """

    namespaces = {
    "spdx": "http://spdx.org/rdf/terms#",
    }
    subgraph = kglab.KnowledgeGraph(
        namespaces = namespaces,
    )
    query = """
    PREFIX spdx:<http://spdx.org/rdf/terms#>
    CONSTRUCT {
    ?element spdx:relationship ?relationship .
    ?element rdf:type ?elementType .
    ?relationship spdx:relatedSpdxElement ?relatedElement .
    ?relationship spdx:relationshipType ?relationshipType .
    ?relatedElement rdf:type ?relatedElementType .
    }
    WHERE {
    ?element spdx:relationship ?relationship .
    ?element rdf:type ?elementType .
    ?relationship spdx:relatedSpdxElement ?relatedElement .
    ?relationship spdx:relationshipType ?relationshipType .
    ?relatedElement rdf:type ?relatedElementType .
    }
    """

    for row in kg.query(query):
        s, p, o = row
        subgraph.add(s, p, o)

    return subgraph

# %% ../nbs/sboms/00_core.ipynb 33
import pandas as pd
from pandas import DataFrame
import json, glob
from os.path import join
from typing import Tuple

def sbomqs_scores(
    sbomqs_dir: str # Directory for the json files generated by the sbomqs tool
    ) -> Tuple[ DataFrame, DataFrame]: # Return two DataFrames, one with the information about each file in `sbomqs_dir` and another with scores for each feature in the SBOM quality categories for all files
    """
    Create DataFrame with quality scores for the SBOM generation tools.
    """
    
    fname_list = glob.glob(join(sbomqs_dir,"*.json"))

    sbomqs_dct = {       
                'gen_tool_name':[],            
                'avg_score':[],
                'num_components':[],  
                'gen_tool_version':[],
                'spec_version':[],                      
                'file_name':[],
                'scores': [],
                }

    for fname in fname_list:
        data = json.loads(open(fname, "r").read())['files'][0]
        for col in sbomqs_dct.keys():        
            sbomqs_dct[col].append(data[col]) 
        
    sbomqs_df = pd.DataFrame.from_dict(sbomqs_dct)
    sbomqs_df.sort_values(by=['avg_score', 'num_components'], ascending=False, inplace=True)
    
    # get score details
    feature_qscores = pd.concat([ pd.DataFrame.from_dict(row['scores']).assign(tool=row['gen_tool_name']) 
                              for _, row in sbomqs_df.iterrows()])
    
    sbomqs_df.drop('scores', axis=1, inplace=True)
    
    return sbomqs_df, feature_qscores

# %% ../nbs/sboms/00_core.ipynb 37
import numpy as np
import pandas as pd
from pandas import DataFrame

def sbomqs_score_by_cat(
    feature_qscores: DataFrame  # It is a DataFrame with the quality scores for each feature in each category for all tools.
    ) -> DataFrame:             # Return a DataFrame with the average scores by categories for the SBOM generation tools.            
    """
    Create a DataFrame with the average score by category for each SBOM generation tool
    """
    
    # average score by category
    avg_score_by_cat = pd.pivot_table(feature_qscores, values='score', index=['category'], columns=['tool'], aggfunc=np.mean)

    # Sort by NTIA-minimum-elements
    id_sort = np.argsort(avg_score_by_cat.iloc[0,:].values, axis=-1, order=None)
    avg_score_by_cat = avg_score_by_cat.iloc[:,id_sort[::-1]]
    
    # reset index 
    avg_score_by_cat.reset_index(inplace=True, level=0)

    # show for each tool the average score by category
    return avg_score_by_cat

# %% ../nbs/sboms/00_core.ipynb 42
import kglab
def visualize_graph(kg:KnowledgeGraph, #Knowledge graph to query from
                    VIS_STYLE: str={} #Optional, visualization style
                    ):
    """
    Visualize the knowledge graph
    """
    if not VIS_STYLE:
        VIS_STYLE = {
            "spdx": {
                "color": "orange",
                "size": 40,
            },
            "rdf":{
                "color": "blue",
                "size": 30,
            },
            "ptr":{
                "color": "red",
                "size": 20,
            },
        }
    subgraph = kglab.SubgraphTensor(kg)
    return subgraph.build_pyvis_graph(notebook=True, style=VIS_STYLE)

# %% ../nbs/sboms/00_core.ipynb 45
import kglab
from pyvis.network import Network

def visualize_relationship_graph(
    kg: KnowledgeGraph,     # Knowledge graph to query from
    hideTypeFile: str=False # Flag for showing SPDX:File type components in the graph
    ) -> Network:           # Return a Network object representing the SBOMs relationship graph

    """
    Construct a Network object for representing the SBOMs components relationship graph.
    The returned graph is ready to be visualized using `.show()`. 
    """
    
    def get_node_title(elmName: str, elmType: str, elmVersion: str, elemPurpose: str) -> str:
        """
        Create a node title. 
        The title will be the node hover text.
        """
        nodeTitle = f"{elmType}: {elmName}"
        if elmVersion:
            nodeTitle += f"\nVersion:{elmVersion}"
        if elemPurpose:
            nodeTitle += "\nPurpose: " + elemPurpose.split("purpose_")[1]
        return nodeTitle

    def get_node_label(elmName: str, elmVersion: str) -> str:
        """
        Create a node label. 
        The label will be the text under the node.
        """
        nodeLabel = elmName
        if elmVersion: nodeLabel += "==" + elmVersion
        return nodeLabel
    
       
    VIS_STYLE = { 
        'SpdxDocument': {
            "color": "#DE3163",
            "size": 20,
        },
        'Package': {
            "color": "#99ccff",
            "size": 20,
        },
        'File': {
            "color": "#FFBF00",
            "size": 15,
        },
    }
    
    SPDX_NS = "http://spdx.org/rdf/terms#"
    
    QUERY = """
    PREFIX spdx:<http://spdx.org/rdf/terms#>
    PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
    
    SELECT
        ?element
        ?elementName
        ?elementType
        ?elementVersionInfo
        ?elementPrimaryPackagePurpose
        ?relatedElement
        ?relationshipType
        ?relatedElementName
        ?relatedElementType
        ?relatedElementVersionInfo
        ?relatedElementPrimaryPackagePurpose
        
    WHERE {
        ?element spdx:relationship ?relationship .
        ?element rdf:type ?elementType .
        ?relationship spdx:relatedSpdxElement ?relatedElement .
        ?relationship spdx:relationshipType ?relationshipType .
        ?relatedElement rdf:type ?relatedElementType .
        
        OPTIONAL { ?element spdx:name ?elementName . }
        OPTIONAL { ?element spdx:fileName ?elementName . }
        OPTIONAL { ?element spdx:primaryPackagePurpose ?elementPrimaryPackagePurpose . }
        OPTIONAL { ?relatedElement spdx:name ?relatedElementName . }
        OPTIONAL { ?relatedElement spdx:fileName ?relatedElementName . }
        OPTIONAL { ?element spdx:versionInfo ?elementVersionInfo .}
        OPTIONAL { ?relatedElement spdx:versionInfo ?relatedElementVersionInfo .}
        OPTIONAL { ?relatedElement spdx:primaryPackagePurpose ?relatedElementPrimaryPackagePurpose . }
    }
    """
    
    # run query
    query_result = kg.query(QUERY)

    # hide from query_result the components of the spdx:File type     
    if hideTypeFile:
        query_result = [ row for row in query_result if str(row.relatedElementType).split(SPDX_NS)[-1] != "File"]
        
    # create a graph of the relationships using Network
    relationship_graph = Network(notebook=True, directed=True, cdn_resources="remote")
    
    # update the graph of the relationships based on the query_result
    for row in query_result:
        
        # element
        elementName = str(row.elementName)
        elementType = str(row.elementType).split(SPDX_NS)[-1]
        elementVersionInfo = row.elementVersionInfo
        elementPrimaryPackagePurpose= row.elementPrimaryPackagePurpose
        
        # relationship
        relationshipTypeName = row.relationshipType.split("relationshipType_")[1]
        
        # relatedElement        
        relatedElementName = str(row.relatedElementName)
        relatedElementType = str(row.relatedElementType).split(SPDX_NS)[-1]
        relatedElementVersionInfo = row.relatedElementVersionInfo
        relatedElementPrimaryPackagePurpose = row.relatedElementPrimaryPackagePurpose

        ## update graph
        # element Node info
        elementNodeId = row.element 
        elementNodeLabel = get_node_label(elementName, elementVersionInfo)
        elementNodeTitle = get_node_title(elementName, elementType, 
                                          elementVersionInfo, elementPrimaryPackagePurpose)
        elementNodeColor = VIS_STYLE[elementType]['color']
        elementNodeSize = VIS_STYLE[elementType]['size']        
        
        # relatedElement Node info
        relatedElementNodeId = row.relatedElement 
        relatedElementNodeLabel = get_node_label(relatedElementName, relatedElementVersionInfo)
        relatedElementNodeTitle = get_node_title(relatedElementName, relatedElementType, 
                                                 relatedElementVersionInfo, relatedElementPrimaryPackagePurpose)
        relatedElementNodeColor = VIS_STYLE[relatedElementType]['color']
        relatedElementNodeSize = VIS_STYLE[relatedElementType]['size']            
        
        # add nodes (elementName, relatedElementName) to the graph
        relationship_graph.add_node(elementNodeId,
                                    label = elementNodeLabel,
                                    title = elementNodeTitle,
                                    color = elementNodeColor,
                                    size = elementNodeSize
                                   )
        relationship_graph.add_node(relatedElementNodeId,
                                    label = relatedElementNodeLabel,
                                    title = relatedElementNodeTitle,
                                    color = relatedElementNodeColor,
                                    size = relatedElementNodeSize
                                   )
        # and edge(relatedElementName) to the graph
        relationship_graph.add_edge(elementNodeId,
                                    relatedElementNodeId,
                                    title = relationshipTypeName,
                                    label = relationshipTypeName # text over the edge
                                   )
    return relationship_graph

# %% ../nbs/sboms/00_core.ipynb 46
from pandas import DataFrame
def display_relationship_graph_legend():    
    """
    Display the legend of the SBOMs components relationship graph that can be visualized by `visualize_relationship_graph()`.
    """    
    legend_df = DataFrame([['File', 'Yellow'], ['Package', 'Blue'], ['SPDXDocument', 'Red']], 
                  columns=['SPDX Type', 'Node Color'])

    display(legend_df)


# %% ../nbs/sboms/00_core.ipynb 51
from pandas import DataFrame
from IPython.core.display import HTML

def display_qscores_with_descriptions(
    feature_qscores: DataFrame, # DataFrame with the quality scores for each feature in each category for all tools.    
    category_list: list = None, # List of categories to be displayed. If None, all categories are displayed.
    tool_list: list = None      # List of tools to be displayed. If None, all tools are displayed.
    )-> None:
    
    category_list = feature_qscores['category'].unique() if category_list is None else category_list     
    tool_list = feature_qscores['tool'].unique() if tool_list is None else tool_list
    tool_score = feature_qscores[feature_qscores['tool'].isin(tool_list)][['tool', 'score']].groupby('tool').mean().reset_index()
    for tool_name, tool_avg_score in tool_score.values:
        display(HTML(f"<h2>Tool: {tool_name} (avg score: {tool_avg_score:0,.2f})</h2>"))
        for cat in category_list:        
            df = feature_qscores.loc[(feature_qscores['category']==cat) & (feature_qscores['tool']==tool_name)]
            cat_avg_score = df["score"].mean()        
            display(HTML(f"<h3>Category: {cat} (avg score: {cat_avg_score:0,.2f})"))
            display(df[['feature', 'score', 'description', 'tool']])    
            display(HTML(f"<hr>"))


# %% ../nbs/sboms/00_core.ipynb 54
import matplotlib.pyplot as plt
from IPython.core.display import HTML
import seaborn as sns

def display_category_qscores_heatmap(
    feature_qscores: DataFrame, # DataFrame with the quality scores for each feature in each category for all tools.    
    category_list: list = None  # List of categories to be displayed. If None, all categories are displayed.
    )-> None:
    
    """
    This function displays a heatmap for each SBOM quality category showing scores by tools for each category feature.    
    """
    
    category_list = feature_qscores['category'].unique() if category_list is None else category_list
    
    for cat in category_list:    
        title = f"Scores by Tools for each Feature in the {cat} Category"        
        score_in_details_cat = feature_qscores[feature_qscores['category']==cat]             
        sns.heatmap(score_in_details_cat.pivot(index="tool", columns="feature", values="score"), 
            linecolor='white',linewidths=0.5, annot=True, cmap="crest")
        display(HTML(f"<h1 style=\"background-color:powderblue;\">Category: {cat}</h1>"))
        
        plt.title(title, y=1.05, fontsize = 16)
        plt.show()


# %% ../nbs/sboms/00_core.ipynb 56
import matplotlib.pyplot as plt
from IPython.core.display import HTML
import seaborn as sns

def display_qscores_heatmap(
    feature_qscores,  # DataFrame with the quality scores for each feature in each category for all tools.
    ) -> None:
    """
    This function display a heatmap showing scores by tools for each SBOM quality category.    
    """
    
    chart_data = sbomqs_score_by_cat(feature_qscores).melt(id_vars=["category"])
    chart_data.columns = ['Category', 'Tool', 'Score']
    
    title = "Scores by Tools for each SBOM Quality Category"
    #display(HTML(f"<h1 style=\"background-color:powderblue;\">{title}</h1>"))
    sns.heatmap(chart_data.pivot(index="Tool", columns="Category", values="Score"), 
                linecolor='white',linewidths=0.5, annot=True, cmap="crest").set(title=title)
    plt.show()

# %% ../nbs/sboms/00_core.ipynb 58
import seaborn as sns
import plotly.express as px
from plotly.graph_objects import Figure
import plotly.io as pio


def sbomqs_radar_chart(
    feature_qscores  # DataFrame with the quality scores for each feature in each category for all tools.                       
    ) -> None:
    """
    Construct a radar chart for the quality scores of the SBOMs categories for each tool.
    
    """

    pio.renderers.default = 'vscode'
    
    num_tools = feature_qscores['tool'].nunique()
    color_discrete_sequence = sns.color_palette("hls", num_tools)

    chart_data = sbomqs_score_by_cat(feature_qscores).melt(id_vars=["category"])
    chart_data.columns = ['Category', 'Tool', 'Score']

    fig = px.line_polar(chart_data, r="Score",
                        theta="Category",
                        color="Tool",
                        line_close=True,
                        color_discrete_sequence=color_discrete_sequence.as_hex(),
                        template="plotly_dark")

    fig.update_polars(angularaxis_showgrid=True,
                    radialaxis_gridwidth=1,
                    gridshape='linear',
                    bgcolor="#494b5a",
                    radialaxis_showticklabels=False,               
                    )

    fig.update_layout(paper_bgcolor="#2c2f36",
                    autosize=False,
                    width=1000,
                    height=700,)

    fig.show()
    #fig.write_image('../figs/sbomqs_radar_chart.png')

